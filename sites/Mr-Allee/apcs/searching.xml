<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE xsl:stylesheet [<!ENTITY nbsp "&#160;">]> 
<?xml-stylesheet type="text/xsl" href="/xsl/main.xsl"?>
<page xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
<h1>Searching and Sorting</h1>
<h2>Note about passing an array as a parameter:</h2>
<table class="notes">
<tr class="notes">
	<td class="desc">When an array is passed as a parameter to a method, and the method changes elements of the array, the original array is affected.  
			This is just like passing an object reference to a method; if the method alters the object through the object reference, the original object is affected.  An array variable is a reference to the array.
	</td>
</tr>
</table>
<br/>
<br/>
<h2>Linear Search:</h2>
<table class="notes">
<tr class="notes">
	<td class="code">
		// precondition: list has at least one element<br/>
		// postcondition: returns index of key in list, or -1 if not found<br/>
		public static int linearSearch(int[] list, int key) {<br/>
			&nbsp;&nbsp;for (int i = 0; i &lt; list.length; i++) {<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;if (list[i] == key) {<br/>
					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return i;<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
			&nbsp;&nbsp;}<br/>
			&nbsp;&nbsp;return -1;<br/>
		}
	</td>
	<td class="desc">Starts at the beginning of an array and searches for the first occurence of a value</td>
</tr>
</table>
<br/>
<br/>
<h2>Selection Sort:</h2>
<table class="notes">
<tr class="notes">
	<td class="code">
	// precondition: list is an instantiated array<br/>
	// postcondition: the elements of list are in increasing order<br/><br/>
	public static void selectionSort(int[] list) {<br/><br/>
		&nbsp;&nbsp;int minIndex;<br/>
		&nbsp;&nbsp;for (int i=0; i &lt; list.length-1; i++) {<br/>
			&nbsp;&nbsp;&nbsp;&nbsp;//find smallest element in list starting at location i<br/>
			&nbsp;&nbsp;&nbsp;&nbsp;minIndex = i;<br/>
			&nbsp;&nbsp;&nbsp;&nbsp;for (int j = i+1; j &lt; list.length; j++)<br/>
			    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (list[j] &lt; list[minIndex])<br/>
				    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;minIndex = j;<br/><br/>
			&nbsp;&nbsp;&nbsp;&nbsp;//swap list[i] with smallest element<br/>
			&nbsp;&nbsp;&nbsp;&nbsp;int temp = list[i];<br/>
			&nbsp;&nbsp;&nbsp;&nbsp;list[i] = list[minIndex];<br/>
			&nbsp;&nbsp;&nbsp;&nbsp;list[minIndex] = temp;<br/>
		&nbsp;&nbsp;}<br/>
<br/>
	}
	</td>
	<td class="desc">A nested for loop structure is used to sort the array.  Each pass through the outer loop puts the next smallest element
			at the front of the array</td>
</tr>
</table>
<br/>
<br/>
<h2>Insertion Sort:</h2>
<table class="notes">
<tr class="notes">
	<td class="code">
	// precondition: list is an instantiated array<br/>
	// postcondition: the elements of list are in increasing order<br/><br/>
	public static void insertionSort (int[] numbers) {<br/><br/>
		&nbsp;&nbsp;for (int index = 1; index &lt; numbers.length; index++) {<br/>
			&nbsp;&nbsp;&nbsp;&nbsp;int key = numbers[index];<br/>
			&nbsp;&nbsp;&nbsp;&nbsp;int position = index;<br/>
<br/>
			&nbsp;&nbsp;&nbsp;&nbsp;// shift larger values to the right<br/>
			&nbsp;&nbsp;&nbsp;&nbsp;while (position &gt; 0 &amp;&amp; numbers[position-1] > key) {<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numbers[position] = numbers[position-1];<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;position--;<br/>
			&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
            <br/>
			&nbsp;&nbsp;&nbsp;&nbsp;numbers[position] = key;<br/>
		&nbsp;&nbsp;}<br/><br/>
	}<br/>
<br/>
	</td>
	<td class="desc">A nested loop structure is used to sort the array.  If N represents the number of passes that have progressed through the outer loop, then the elements from position 0 through N-1 are in order.  The outer loop takes the next value in the list and <i>inserts</i> it into the lower subset of the list in its proper position.</td>
</tr>
</table>
<br/>
<br/>
<h2>Binary Search:</h2>
<table class="notes">
<tr class="notes">
	<td class="code">
	// precondition: list is an instantiated array,<br/> 
	//               and sorted in ascending order<br/>
	// postcondition: the index of the key is returned.<br/>
	//                if not found -1 is returned<br/><br/>
	public static int binarySearch(int[] numbers, int key) {<br/><br/>
		&nbsp;&nbsp;int low = 0;<br/>
		&nbsp;&nbsp;int high = numbers.length-1;<br/>
		&nbsp;&nbsp;int middle = (low + high) / 2;<br/>
		<br/>
		&nbsp;&nbsp;while (numbers[middle] != key &amp;&amp; low &lt;= high) {<br/>
			&nbsp;&nbsp;&nbsp;&nbsp;if (key &lt; numbers[middle])<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;high = middle - 1;<br/>
			&nbsp;&nbsp;&nbsp;&nbsp;else<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;low = middle + 1;<br/>
			&nbsp;&nbsp;&nbsp;&nbsp;middle = (low + high) / 2;<br/>
			&nbsp;&nbsp;}<br/>
		<br/>
		&nbsp;&nbsp;if (numbers[middle] == key)<br/>
			&nbsp;&nbsp;&nbsp;&nbsp;return middle;<br/>
		&nbsp;&nbsp;else<br/>
			&nbsp;&nbsp;&nbsp;&nbsp;return -1;<br/>
	}<br/>
<br/>
	</td>
	<td class="desc">A while loop is used to continually divide the array in half (hence the word <i>binary</i> search), until it zeros in on the desired value</td>
</tr>
</table>
<br/>
<br/>
</page>
